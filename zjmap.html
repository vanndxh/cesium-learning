<!--
/**
 * @Author: vanndxh
 * @Date: 2022-4-14
 * @LastModified: 2022-4-18
 */
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>浙江省地图影像demo</title>

    <script type="text/javascript" src="./node_modules/cesium/Build/Cesium/Cesium.js"></script>
    <style>
        @import url(./node_modules/cesium/Build/CesiumUnminified/Widgets/widgets.css);
        @import "zjmap.css";
        /*@import "cesium-viewshed.js";*/

        html, body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>

</head>

<body>
<!--tabBar-->
<h1 class="title" onclick="go(0)">浙江省地图影像demo</h1>
<h1 class="title" style="margin: 10px 0 10px 2px">v0.0.3</h1>
<p style="display: inline-block; font-size: 14px; margin: 10px 0 10px 190px">by: vanndxh</p>

<button class="button" onclick="go(0)">回起点</button>
<button class="button" onclick="go(1)">去浙江</button>
<button class="button" onclick="go(2)">去诸暨</button>

<!--<button class="button2" onclick="clearFX()">清除分析</button>-->
<button class="button2" onclick="addSY()">视域分析</button>
<button class="button2" onclick="addTS()">通视分析</button>
<button class="button3" onclick="viewer.flyTo(tileset);">前往3dtiles测试区</button>
<!--content-->
<div id="cesiumContainer"></div>

<script>
    /**
     * state
     */
    const tokenYX = "cd3f3677-ffee-4e63-a33f-ec2cb31ffae3"
    const tokenZJ = "04a4b863-0c13-48df-a054-0aa35e599bbf"
    const proxyPath = "https://ditu.zjzwfw.gov.cn:443/"

    /**
     * config
     */
    let viewer = new Cesium.Viewer("cesiumContainer", {
        baseLayerPicker: true,
        timeline: false,
        navigationHelpButton: false,
        infoBox: true,
    })
    viewer.scene.debugShowFramesPerSecond = true
    // 中国地区lon & lat
    const lon = 100.48
    const lat = 30
    viewer.camera.setView({destination: Cesium.Cartesian3.fromDegrees(lon, lat, 19000000)})
    function go (type) {
        if (type === 2) {
            viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(120.25, 29.7, 30000)})
        } else if (type === 1) {
            viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(120.5, 29, 1000000) })
        } else if (type === 0) {
            viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(lon, lat, 19000000) })
        }
    }

    /**
     * 地图影像
     */
    viewer.imageryLayers.addImageryProvider(
        new Cesium.WebMapTileServiceImageryProvider({
            url: proxyPath + "services/wmts/imgmap/default/oss?request=getcapabilities&service=wmts&token=" + tokenYX,
            layer: "imgmap",
            style: "default",
            format: "image/png",
            tileMatrixSetID: "esritilematirx",
            //minimumLevel:9,
            maximumLevel: 20,//控制最大级别为20
            //tilingScheme:new Cesium.GeographicTilingScheme(),//2000坐标系
            tilingScheme:new Cesium.GeographicTilingScheme({
                ellipsoid:Cesium.Ellipsoid.WGS84,
                rectangle:new Cesium.Rectangle(-Math.PI,-Math.PI*3/2,Math.PI,Math.PI/2),
                numberOfLevelZeroTilesX:1,
                numberOfLevelZeroTilesY:1
            }),
            credit: new Cesium.Credit("浙江省影像")
        })
    )

    /**
     * 地图注记
     */
    viewer.imageryLayers.addImageryProvider(
        new Cesium.WebMapTileServiceImageryProvider({
            url: proxyPath + "services/wmts/imgmap_lab/default/oss?request=getcapabilities&service=wmts&token=" + tokenZJ,
            layer: "imgmap_lab",
            style: "default",
            format: "image/png",
            tileMatrixSetID: "esritilematirx",
            //minimumLevel:11,
            maximumLevel: 20,//控制最大级别为20,
            //tilingScheme:new Cesium.GeographicTilingScheme(),//2000坐标系
            tilingScheme:new Cesium.GeographicTilingScheme({
                ellipsoid:Cesium.Ellipsoid.WGS84,
                rectangle:new Cesium.Rectangle(-Math.PI,-Math.PI*3/2,Math.PI,Math.PI/2),
                numberOfLevelZeroTilesX:1,
                numberOfLevelZeroTilesY:1
            }),
            credit: new Cesium.Credit("浙江省影像注记")
        })
    )

    /**
     * 查看经纬度功能
     */
    let scene = viewer.scene
    let entity = viewer.entities.add({
        label: {
            show: false,
            showBackground: true,
            font: "14px monospace",
            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
            verticalOrigin: Cesium.VerticalOrigin.TOP,
            pixelOffset: new Cesium.Cartesian2(30, 0),
        },
    });
    // Mouse over the globe to see the cartographic position
    let handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
    handler.setInputAction(function(movement) {
        let cartesian = viewer.camera.pickEllipsoid(
            movement.endPosition,
            scene.globe.ellipsoid
        );
        if (cartesian) {
            let cartographic = Cesium.Cartographic.fromCartesian(cartesian);
            let longitudeString = Cesium.Math.toDegrees(
                cartographic.longitude
            ).toFixed(6);
            let latitudeString = Cesium.Math.toDegrees(
                cartographic.latitude
            ).toFixed(6);
            entity.position = cartesian;
            entity.label.show = true;
            entity.label.text =
                "Lon:" + (" " + longitudeString).slice(-10) + "\u00B0" +
                "\nLat:" + (" " + latitudeString).slice(-10) + "\u00B0"
        } else {
            entity.label.show = false;
        }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    /**
     * 地形
     */
    viewer.terrainProvider = Cesium.createWorldTerrain({
        requestWaterMask : true, // required for water effects
        requestVertexNormals : false // required for terrain lighting
    });

    /**
     * 通视分析
     */
    function addTS () {
        viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(115.77774943, 40.51669238, 2000)})
        // 开启地形深度监测
        viewer.scene.globe.depthTestAgainstTerrain = true;

        // 设定初始视角位置点
        let viewPoint = Cesium.Cartesian3.fromDegrees(115.77774943, 40.51669238, 1000);
        let viewPointEntity = viewer.entities.add({
            position: viewPoint,
            ellipsoid: {
                // radii: new Cesium.Cartesian3(5, 5, 5),
                material: Cesium.Color.YELLOW
            },
        });

        // 视角位置创建坐标轴
        let transform = Cesium.Transforms.eastNorthUpToFixedFrame(viewPoint);
        let modelMatrixPrimitive = viewer.scene.primitives.add(new Cesium.DebugModelMatrixPrimitive({
            modelMatrix: transform,
            length: 10.0
        }));

        // 世界坐标转换为投影坐标
        let webMercatorProjection = new Cesium.WebMercatorProjection(viewer.scene.globe.ellipsoid);
        let viewPointWebMercator = webMercatorProjection.project(Cesium.Cartographic.fromCartesian(viewPoint));

        // 排除碰撞监测的对象
        let objectsToExclude = [viewPointEntity, modelMatrixPrimitive];

        // 目标点集合
        let TargetPoints = [];

        // 视域点和目标点的距离
        let radius = 0;

        // 计算45°和135°之间的目标点
        for (let i = 45; i <= 135; i++) {
            let linePoints = [];//记录一条线上的所有目标点
            let pointsNum = 15;//该方向插值点数
            let lineDis = 200;//每两个插值点之间的距离m1
            for (let index = 0; index < pointsNum; index++) {
                radius = index * lineDis;
                // 度数转弧度
                let radians = Cesium.Math.toRadians(i);
                // 计算目标点
                let toPoint = new Cesium.Cartesian3(viewPointWebMercator.x + radius * Math.cos(radians), viewPointWebMercator.y + radius * Math.sin(radians), 0);
                // 投影坐标转世界坐标
                toPoint = webMercatorProjection.unproject(toPoint);
                // TargetPoints.push(Cesium.Cartographic.toCartesian(toPoint.clone()));
                let m_cartesian3 = Cesium.Cartographic.toCartesian(toPoint.clone());
                let m_ellipsoid = viewer.scene.globe.ellipsoid;
                let m_cartographic = m_ellipsoid.cartesianToCartographic(m_cartesian3);
                let m_height = viewer.scene.globe.getHeight(m_cartographic);
                let m_point = Cesium.Cartesian3.fromDegrees(m_cartographic.longitude / Math.PI * 180, m_cartographic.latitude / Math.PI * 180, m_height);
                linePoints.push({
                    data: m_point,
                    show: true
                });
            }
            TargetPoints.push({
                id: i,
                points: linePoints
            });
        }
        pickFromRay();

        function pickFromRay() {
            for (let i = 0; i < TargetPoints.length; i++) {
                let cur_LinePoints = TargetPoints[i].points;
                cur_LinePoints.forEach(element => {
                    // 计算射线的方向&#xff0c;目标点left 视域点right
                    let direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(element.data, viewPoint, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                    // 建立射线
                    let ray = new Cesium.Ray(viewPoint, direction);
                    // let results = viewer.scene.drillPickFromRay(ray, 10, objectsToExclude); // 计算所有的交互点&#xff0c;最大不超过10个
                    let result = viewer.scene.pickFromRay(ray, objectsToExclude); // 计算交互点&#xff0c;返回第一个
                    let buffer = ReturnDistance(element.data, result.position);
                    // let M_color = Cesium.Color.GREEN;
                    if (buffer > 10) {
                        // M_color = Cesium.Color.RED;
                        element.show = false;
                    }
                });

            }
            drawViewshedLine(TargetPoints);
        }

        function drawViewshedLine(data) {
            for (let index = 0; index < data.length; index++) {
                const element = data[index].points;
                let startIndex = 0;
                for (let i = 0; i < element.length; i++) {
                    let defaultColor = new Cesium.Color(0.1, 1, 0.1, 0.3);
                    // console.log(&#34;第&#34; + i + &#39;个点的起点是&#xff1a;&#39; + startIndex);
                    const m_linestart = element[startIndex];
                    let m_lineshow = m_linestart.show;
                    const m_lineCurrent = element[i];
                    const m_lineEnd = element[i + 1];
                    if (m_lineEnd && m_lineCurrent.show != m_lineEnd.show) {
                        if (!m_lineshow) {
                            defaultColor = new Cesium.Color(1, 0.1, 0.1, 0.3);
                        }
                        viewer.entities.add({
                            polyline: {
                                positions: [m_linestart.data, m_lineEnd.data],
                                width: 2,
                                material: defaultColor,
                                clampToGround: true
                            }
                        });
                        startIndex = i + 1;
                    }
                    else if (!m_lineEnd) {
                        if (!m_lineshow) {
                            defaultColor = new Cesium.Color(1, 0.1, 0.1, 0.3);
                        }
                        viewer.entities.add({
                            polyline: {
                                positions: [m_linestart.data, m_lineCurrent.data],
                                // arcType: Cesium.ArcType.NONE,
                                width: 2,
                                material: defaultColor,
                                // depthFailMaterial: defaultColor,
                                clampToGround: true
                            }
                        });
                    }

                }
            }
        }

        //空间两点距离计算函数
        function ReturnDistance(pos0, pos1) {
            let distance = 0;
            let point1cartographic = Cesium.Cartographic.fromCartesian(pos0);
            let point2cartographic = Cesium.Cartographic.fromCartesian(pos1);
            // 根据经纬度计算出距离
            let geodesic = new Cesium.EllipsoidGeodesic();
            geodesic.setEndPoints(point1cartographic, point2cartographic);
            let s = geodesic.surfaceDistance;
            return s.toFixed(2);
        }

        // 处理交互点
        function showIntersection(result, destPoint, viewPoint) {
            // 如果是场景模型的交互点&#xff0c;排除交互点是地球表面
            if (Cesium.defined(result) && Cesium.defined(result.object)) {
                drawLine(result.position, viewPoint, Cesium.Color.GREEN); // 可视区域
                drawLine(result.position, destPoint, Cesium.Color.RED); // 不可视区域
            } else {
                drawLine(viewPoint, destPoint, Cesium.Color.GREEN);
            }
        }
    }

    function clearFX () {
        if (viewshed) {
            viewshed.close();
            viewshed = null;
        }
    }

    /**
     * 按键移动camera
     */
    let flags = {
        looking : false,
        moveForward : false,
        moveBackward : false,
        moveUp : false,
        moveDown : false,
        moveLeft : false,
        moveRight : false
    };
    function getFlagForKeyCode(keyCode) {
        switch (keyCode) {
            case 'W'.charCodeAt(0):
                return 'moveForward';
            case 'S'.charCodeAt(0):
                return 'moveBackward';
            case 'Q'.charCodeAt(0):
                return 'moveUp';
            case 'E'.charCodeAt(0):
                return 'moveDown';
            case 'D'.charCodeAt(0):
                return 'moveRight';
            case 'A'.charCodeAt(0):
                return 'moveLeft';
            default:
                return undefined;
        }
    }
    document.addEventListener('keydown', function(e) {
        let flagName = getFlagForKeyCode(e.keyCode);
        if (typeof flagName !== 'undefined') {
            flags[flagName] = true;
        }
    }, false);

    document.addEventListener('keyup', function(e) {
        let flagName = getFlagForKeyCode(e.keyCode);
        if (typeof flagName !== 'undefined') {
            flags[flagName] = false;
        }
    }, false);

    let ellipsoid = viewer.scene.globe.ellipsoid;
    viewer.clock.onTick.addEventListener(function(clock) {
        let camera = viewer.camera;

        if (flags.looking) {
            let width = canvas.clientWidth;
            let height = canvas.clientHeight;

            // Coordinate (0.0, 0.0) will be where the mouse was clicked.
            let x = (mousePosition.x - startMousePosition.x) / width;
            let y = -(mousePosition.y - startMousePosition.y) / height;

            let lookFactor = 0.05;
            camera.lookRight(x * lookFactor);
            camera.lookUp(y * lookFactor);
        }

        // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
        let cameraHeight = ellipsoid.cartesianToCartographic(camera.position).height;
        let moveRate = cameraHeight / 100.0;

        if (flags.moveForward) {
            camera.moveForward(moveRate);
        }
        if (flags.moveBackward) {
            camera.moveBackward(moveRate);
        }
        if (flags.moveUp) {
            camera.moveUp(moveRate);
        }
        if (flags.moveDown) {
            camera.moveDown(moveRate);
        }
        if (flags.moveLeft) {
            camera.moveLeft(moveRate);
        }
        if (flags.moveRight) {
            camera.moveRight(moveRate);
        }
    });

    /**
     * 视域分析
     */
    let pos
    // viewer.scene.globe.depthTestAgainstTerrain = true;
    // 实现鼠标点击确定观测点
    handler.setInputAction(function(e) {
        // 尝试取模型高度
        // let cartesian
        // if (scene.mode !== Cesium.SceneMode.MORPHING) {
        //     let pickedObject = scene.pick(e.position);
        //     if (scene.pickPositionSupported && Cesium.defined(pickedObject)) {
        //         cartesian = viewer.scene.pickPosition(e.position);
        //         if (Cesium.defined(cartesian)) {
        //             let cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        //             let lng = Cesium.Math.toDegrees(cartographic.longitude);
        //             let lat = Cesium.Math.toDegrees(cartographic.latitude);
        //             let height = cartographic.height;//模型高度
        //             let mapPosition = {x:lng,y:lat,z:height};
        //             pos = mapPosition
        //             console.log(mapPosition);
        //         }
        //     }
        // }
        let cartesian = viewer.camera.pickEllipsoid(
            e.position,
            scene.globe.ellipsoid,
        );
        pos = cartesian
        let entity = viewer.entities.getById('viewPointEntity2');
        viewer.entities.remove(entity)
        viewer.entities.add({
            id: 'viewPointEntity2',
            position: pos,
            ellipsoid: {
                radii: new Cesium.Cartesian3(5, 5, 5),
                material: Cesium.Color.YELLOW
            },
        });
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    function addSY() {
        let options = {
            // position: pos,
            position: Cesium.Cartesian3.fromDegrees(119.68134943, 30.62879238, 30), // 测试用例
            distance: 100,
            direction: Cesium.Math.toRadians(20.0),
            hFOV: 53,
            vFOV: 53,
            color: {
                Fore: Cesium.Color.GREEN,
                Back: Cesium.Color.RED,
            }
        }
        if (pos) {
            // 在观测点处加入指示标
            viewer.entities.add({
                id: 'viewPointEntity3',
                position: options.position,
                ellipsoid: {
                    radii: new Cesium.Cartesian3(5, 5, 5),
                    material: Cesium.Color.YELLOW
                },
            });
            CreateViewshed(options.position, options.distance, options.direction, options)
            alert("视域分析完成！观测点坐标：" + pos)
        } else {
            alert("请先点击地图确定观测点！")
        }
    }

    function CreateViewshed(position, distance, direction, options) {
        let spotLightCamera = new Cesium.Camera(scene);
        let context = scene.context;

        const hr = options.hFOV;
        const vr = options.vFOV;
        spotLightCamera.frustum.aspectRatio = (options.distance * Math.tan(hr / 2) * 2) / (options.distance * Math.tan(vr / 2) * 2);

        if (hr > vr) {
            spotLightCamera.frustum.fov = hr;
        } else {
            spotLightCamera.frustum.fov = vr;
        }
        // spotLightCamera.frustum.fov = options.vFOV; //53 * Math.PI / 180;
        // spotLightCamera.frustum.aspectRatio = 1.0;
        // spotLightCamera.frustum.near = 1.0;
        spotLightCamera.frustum.far = options.distance;
        spotLightCamera.lookAt(position, direction);
        // Cesium.Cartesian3.clone(this._viewer.scene.globe.ellipsoid.geodeticSurfaceNormal(position, new Cesium.Cartesian3), spotLightCamera.up);
        let shadowOptions = {
            context: context,
            lightCamera: spotLightCamera,
            cascadesEnabled: false
        };

        // scene.shadowMap.destroy();
        scene.shadowMap = new Cesium.ShadowMap(shadowOptions);

        let shadowMap = scene.shadowMap;
        if (options.color) {
            shadowMap._viewshed_Back = new Cesium.Cartesian3(1, 0, 0);
            shadowMap._viewshed_Fore = new Cesium.Cartesian3(0, 1, 0);
            // shadowMap._viewshed_Back = new Cesium.Cartesian3(options.color.Back.r, options.color.Back.g, options.color.Back.b);
            // shadowMap._viewshed_Fore = new Cesium.Cartesian3(options.color.Fore.r, options.color.Fore.g, options.color.Fore.b);
        }
        shadowMap.enabled = true;
        shadowMap.debugShow = false;
        shadowMap.guid = Cesium.createGuid();
        // shadowMap._isSpotLight = false;
        shadowMap.show = true;
        shadowMap.maximumDistance = 10000;
        shadowMap._pointLightRadius = distance;
        // Update render states for when polygon offset values change
        shadowMap.debugCreateRenderStates();
        shadowMap._distance = options.distance;
        // Force all derived commands to update
        shadowMap.dirty = true;
        viewer.scene.globe.shadows = Cesium.ShadowMode.fromCastReceive(true, true);
        viewer.scene.globe.show = true;
        scene.skyAtmosphere.show = false;
        let viewsObj = {};
        viewsObj.position = position;
        viewsObj.distance = distance;
        viewsObj.direction = direction;

        viewsObj.viewshedObjOptions = options;
        // viewsObj.guid = this._cesium.createGuid();
        viewsObj.guid = shadowMap.guid
        viewsObj.viewshedObjOptions.originalDirection = direction;
        viewsObj.type = "viewshed";
        viewsObj.viewshedMap = shadowMap;
        this._currentObject = viewsObj;
        // Cesium.createViewshedCameraPrimitive(position, direction);
        // this.createViewshedSpherePrimitive(position, 160)
        return viewsObj;
    }

    /**
     * 另一种可视域分析
     * 这种方法的js无法正常使用，格式为MIME
     */

    // // 分析参数
    // var viewModel = { verticalAngle: 90, horizontalAngle: 120, distance: 10 };
    //
    // // 添加可视域
    // var viewshed = new Cesium.ViewShed3D(viewer, {
    //     horizontalAngle: Number(viewModel.horizontalAngle),
    //     verticalAngle: Number(viewModel.verticalAngle),
    //     distance: Number(viewModel.distance),
    //     callback: function () {
    //         viewModel.distance = viewshed.distance
    //     }
    // });

    /**
     * 加载3d tiles
     */
    let tileset = scene.primitives.add(
        new Cesium.Cesium3DTileset({
            url: "http://172.17.70.209:3866/Smartearth/server/SG/anji.397940/tokens(eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZhbnl1bmxpYW5nIn0.6d019Mi2PbKZ6yY6uRiyuHNq4x2cW5zKugSHBm0iHLo)/b3dm/anji.397940/tileset.json"
        })
    )

</script>

</body>

</html>